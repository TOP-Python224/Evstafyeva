class Point:
    """Описывает точку на плоскости в декартовой системе координат."""

    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y


class Line:
    """Описывает отрезок, задаваемый двумя точками на плоскости в декартовой системе координат."""

    def __init__(self, start_point: Point, end_point: Point):
        self.start_point = start_point
        self.end_point = end_point

    @property
    def length(self) -> float:
        delta_x = self.end_point.x - self.start_point.x
        delta_y = self.end_point.y - self.start_point.y
        return (delta_x ** 2 + delta_y ** 2) ** 0.5


# ИСПРАВИТЬ: согласно диаграмме этот класс должен наследовать от встроенного класса list
class Polygon(list):
    """Описывает многоугольник, задаваемый отрезками на плоскости в декартовой системе координат."""

    def __init__(self, *sides: Line):
        super().__init__()
        self.sides = sides

        # КОММЕНТАРИЙ: смысл такой сигнатуры заключается в том, что минимальное количество сторон многоугольника равно трём — из двух отрезков на плоскости многоугольник не построить — поэтому такой сигнатурой конструктора для создания экземпляра многоугольника мы обязываем использующего передать минимум три отрезка, но при это предоставляем возможность передать большее количество отрезков для многоугольников с бóльшим количеством сторон
        # КОММЕНТАРИЙ: вспоминаем передачу аргументов в функции — здесь перед нами параметр-кортеж, в который может быть передано произвольное количество аргументов; а аннотация относится к элементам этого кортежа (потому что сам объект параметра — всегда кортеж, его не имеет смысл аннотировать)
        # ИСПРАВИТЬ: согласно диаграмме у экземпляров этого класса не должно быть дополнительных полей
        # КОММЕНТАРИЙ: а если и был бы, то только один атрибут кортеж, в котором были бы объединены все переданные отрезки

    def _is_closed(self) -> bool:
        # КОММЕНТАРИЙ: ну это очень грустная история.. а если бы я попросил проверить все явно записанный в атрибуты рёбра додекаэдра (30 штук), то вы для каждой пары также прописывали бы условия?
        # ИСПРАВИТЬ: для перебора элементов некоего контейнера мы используем цикл

        for self.side in self.sides:
            if (self.side.start_point.x == self.side.end_point.x
                    and self.side.start_point.y == self.side.end_point.y):
                # КОММЕНТАРИЙ: потому что — ещё раз — сам объект sides это кортеж; интересующие нас отрезки находятся внутри этого кортежа
                return True

    @property
    def perimetr(self) -> float:
        perimeter = 0
        for self.side in self.sides:
            perimeter += self.side.length
        return perimeter

    # КОММЕНТАРИЙ: начните с переписывания этого класса таким образом, чтобы он наследовал от list — объект экземпляра тогда должен вести себя как список, содержащий все, переданные в конструктор, объекты Line


# тест
p1 = Point(4, 3)
p2 = Point(7, 8)
p3 = Point(10, 4)
p4 = Point(8, 2)

l1 = Line(p1, p2)
l2 = Line(p2, p3)
l3 = Line(p3, p4)
l4 = Line(p4, p1)

print(l1.length)
print(l2.length)
print(l3.length)
print(l4.length)
print()
pol1 = Polygon(l1, l2, l3, l4)
print(pol1.perimetr)

print()

pol1_closed = pol1._is_closed()
print(pol1_closed)

# ИТОГ: многоугольник не задался, а с точкой и отрезком всё нормально, жду работу над ошибками — 4/10

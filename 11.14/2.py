class Point:
    """Описывает точку на плоскости в декартовой системе координат."""
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y


class Line:
    """Описывает отрезок, задаваемый двумя точками на плоскости в декартовой системе координат."""
    def __init__(self, start_point: Point, end_point: Point):
        self.start_point = start_point
        self.end_point = end_point

    @property
    def length(self) -> float:
        delta_x = self.end_point.x - self.start_point.x
        delta_y = self.end_point.y - self.start_point.y
        return (delta_x**2 + delta_y**2)**0.5


# ИСПРАВИТЬ: согласно диаграмме этот класс должен наследовать от встроенного класса list
class Polygon:
    """Описывает многоугольник, задаваемый отрезками на плоскости в декартовой системе координат."""
    def __init__(self,
                 # КОММЕНТАРИЙ: смысл такой сигнатуры заключается в том, что минимальное количество сторон многоугольника равно трём — из двух отрезков на плоскости многоугольник не построить — поэтому такой сигнатурой конструктора для создания экземпляра многоугольника мы обязываем использующего передать минимум три отрезка, но при это предоставляем возможность передать большее количество отрезков для многоугольников с бóльшим количеством сторон
                 side1: Line,
                 side2: Line,
                 side3: Line,
                 # КОММЕНТАРИЙ: вспоминаем передачу аргументов в функции — здесь перед нами параметр-кортеж, в который может быть передано произвольное количество аргументов; а аннотация относится к элементам этого кортежа (потому что сам объект параметра — всегда кортеж, его не имеет смысл аннотировать)
                 *sides: Line):
        # ИСПРАВИТЬ: согласно диаграмме у экземпляров этого класса не должно быть дополнительных полей
        self.side1 = side1
        self.side2 = side2
        self.side3 = side3
        # КОММЕНТАРИЙ: а если и был бы, то только один атрибут кортеж, в котором были бы объединены все переданные отрезки
        self.sides = sides

    def _is_closed(self) -> bool:
        # КОММЕНТАРИЙ: ну это очень грустная история.. а если бы я попросил проверить все явно записанный в атрибуты рёбра додекаэдра (30 штук), то вы для каждой пары также прописывали бы условия?
        # ИСПРАВИТЬ: для перебора элементов некоего контейнера мы используем цикл
        if (self.side1.start_point.x == self.side3.end_point.x
                and self.side1.start_point.y == self.side3.end_point.y
                # КОММЕНТАРИЙ: потому что — ещё раз — сам объект sides это кортеж; интересующие нас отрезки находятся внутри этого кортежа
                or self.side1.start_point.x == self.sides.end_point.x
                and self.side1.start_point.y == self.sides.end_point.y):
            return True
        else:
            return False

    @property
    def perimetr(self) -> float:
        # if Polygon._is_closed is True:
        # Как и в задаче 1 столкнулась с проблемой применения методов, которые работают с типами bool.
        # Помогите разобраться.
            return self.side1.length + self.side2.length + self.side3.length
        # Если добавляю + self.sides.length, то выдает ошибку "AttributeError: 'tuple' object has no attribute 'length'"
        # Как написать код, чтобы он работал вместе с *args?
        # else:
        #     print('Многоугольник разомкнут')
        # КОММЕНТАРИЙ: начните с переписывания этого класса таким образом, чтобы он наследовал от list — объект экземпляра тогда должен вести себя как список, содержащий все, переданные в конструктор, объекты Line


# тест
p1 = Point(5.1, 7.9)
p2 = Point(8, 12)
p3 = Point(7.05, 0.9)

l1 = Line(p1, p2)
l2 = Line(p2, p3)
l3 = Line(p3, p1)
print(l1.length)
print(l2.length)
print(l3.length)

pol1 = Polygon(l1, l2, l3)
print(pol1.perimetr)


# ИТОГ: многоугольник не задался, а с точкой и отрезком всё нормально, жду работу над ошибками — 4/10

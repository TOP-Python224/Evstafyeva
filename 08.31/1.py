# Напишите функцию высшего порядка, которая принимает объект функции, динамический список аргументов для переданной функции и логический ключ.
# В зависимости от значения логического ключа ФВП возвращает объект float (False) либо str (True, по-умолчанию) – в обоих случаях значение должно быть округлено до двух знаков после запятой
# Вызовите написанную функцию, передав ей lambda-функцию
# Подсказка: в lambda-функции опишите простые математические функции, например, линейную функцию f(x) = kx + b, параболическую g(x) = ax^2 + bx + c, и т.п.
# Протестируйте с различными lambda-функциями и наборами аргументов


# ИСПОЛЬЗОВАТЬ: в данном случае уместнее импорт отдельных функций, а не всего модуля и не смешанный, который был у вас
from random import randrange as rr, uniform, choice


# КОММЕНТАРИЙ: данное утверждение не имеет смысла, так как:
#  1) аннотация является только подсказкой того, какой тип аргумента ожидается — аннотация не влияет на тип передаваемого аргумента
#  2) здесь у вас аннотирован только параметр c, но не параметры a и b
# Если у коэффициентов a, b, c в аннотации указать тип str (в данном варианте кода), функция возвращает None, поэтому заменила тип str на int

# ИСПРАВИТЬ: ваша функция не является функцией высшего порядка, так как не принимает объект другой функции в качестве аргумента
def math_func(a, b, c: int | float) -> bool:
    """Возвращает True или False в зависимости от типа входных параметров функции f(x) = a*x**2 + b*x + c."""
    # КОММЕНТАРИЙ: вы создали здесь объект функции, но никак его не используете — однако, создавать lambda-функцию нужно было не здесь, а во время вызова функции math_func()
    lambda x: a*x**2 + b*x + c
    # КОММЕНТАРИЙ: в задании не было сказано, что функция должна вернуть логическое значение
    if type(x) is int:
        return True
    if type(x) is float:
        return False


a, b, c = [rr(1, 10) for _ in range(3)]
print(f'{a, b, c = }')
x = choice([
    rr(1, 20),
    round(uniform(1.1, 19.9), 2)
])
print(f'{x = }')

# КОММЕНТАРИЙ: во время вызова функции высшего порядка вы должны ей передать объект другой функции — для этого вполне подойдёт lambda-функция, мы можем её создать непосредственно во время передачи в качестве аргумента
f = math_func(a, b, c)
print(f)


# stdout:
# a, b, c = (2, 9, 8)
# x = 14
# True

# a, b, c = (5, 1, 2)
# x = 10.17
# False


# ИТОГ: внимательно перечитать условие задачи, лучше несколько раз, и полностью переписать задачу — 1/12
